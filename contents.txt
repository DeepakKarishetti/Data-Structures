CONTENTS:


 - Knowing basic data structures.

 - Understand and use most of C++ features.
	- Pointers and dynamic memory management.
	- Templates.
	- Inheritance.

 - Performance of algorithms.
	- Measure performance.
	- Analyze performance of algorithm.
	- Performance of algorithms and data structure operations.



Data structures:



 -> Linked list

	 - It is a linear data structure like arrays but not stored at contiguous locations.
	 - The elements in a linked list are linked using pointers. 
	 - Linked list structure consists of node objects and each node consists of one data value. Each node contains a pointer to the next node, and nodes can be independently created or destroyed.

	 - Applications:
		 - Low level data structure for implementing - stacks and queues.
		 - Linear contained for use when lots of cutting/splicing operations are important
		 - Keeping track of undo chains
		 - Other data structures - hashtables and graphs



 -> Stacks and queues

	 - Only permits operations at the ends.
	 - Easily implemented with linked lists.
	 - Lots of applications despite its simplicity.


	 -> Stacks (LIFO): #include <stack>

		 -  Three operations: top (look the top element), push (add element to the top of stack) and pop (remove top item from the stack), size(), empty().

		 - Applications: 
			 - Syntax analysis (Nested structures)
			 - Searching branching structures (trees and mazes)
			 - Programming languages or processors

	
	 -> Queues (FIFO): #include <queue>
	
		 - Adding an item to a queue: enqueue and removing an item from a queue: de-queue.
		 - Operations: push(), pop(), front(), back(), size(), empty().

		 - Applications:
			 - Anything to keep thiings in order by the time of arrival.
			 - Buffering character input 
			 - I/O request scheduling
			 - Event handling (GUI, simulations, etc.)



 -> Graphs
	
	 - It is a type of data structure that consists of a finite sets of vertices called as nodes and a finite set of ordered pairs called as edge which contain weight/value/cost.
	 - Graphs are used to represent many real-life applications. They are extensively used to represent networks.

	 - Two key algorithms used in graph search are:
		 - Depth-first search -> using recursion or stacks
		 - Breadth-first search -> easy with using queues


 -> Recursion:
		
	 - Call a funtion from within a function as long as the base case is not satisfied.
	 - Having a base case is the most important part of recursion.
	 - Simple and is better than iteration if not for some storage and immediate results.

	 - Recursive decomposition:
		 - Reducing a problems into smaller sub problems and solving them ass as original problems.

	 - Recursion as induction:
		 - Basic form of recursion follows that of induction.
		 - If we solve for a problem of size n, then we can do the same with a problem of size n+1

 - Example: The Towers of Hanoi -> Uses both decomposition and induction.
 	    The maze problem
	    Minimax 

 - Divide and Conquer:
	 - Split the problem into multiple smaller problems
	 - Solve the sub problems recursively
	 - Recombine the solution afterwards
	 - Used only if splitting/recombination can be performed efficiently



Analysis of recursive algorithms
	 - Binary search
	 - Merge sort


 -> Binary search:
	
	 - Complexity before we get to length 1 = O(log n)
	 - Search for a value in a sorted list
			 - Start at the element present at the index number half of the total list size.
			 - If the element is less than the one looking for then go to the left half of the values or else to the right and search similarly at the half the size length of the list size element.
			 - This is recursively done until the element is found.

 -> Merge Sort:

	 - Height of the tree = log n and the time complexity = O(n*log n)
	 - Divide and conquer algorithm
	 - Split the input list into half
	 - Sort the halves recursively
	 - Merge the sorted lists



